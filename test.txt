//J B WS ALUop  RA1   RA2   const     WA
  0 0 10   00000000000000000000000   00001  // reg[1] = swi_i                        li x1, 65    # sw_i - входное число
  0 0 00   00000000000000000000000   00010  // reg[2] = 0                            li x2, 0     # временная переменная для подсчета единиц
  0 0 00   00000000000000000000001   00011  // reg[3] = 1                            li x3, 1     # константа 1 для сравнений и сдвигов
  0 0 00   00000000000000000000000   00100  // reg[4] = 0                            li x4, 0     # результат (out_o)

// loop:                                                                              
  0 1 00 11000 00001 00000 00000101  00000 // if (reg[1] == reg[0]) PC = PC + 5      beq x1, x0, end # если вх. число стало 0, завершаем подсчет
  0 0 01 00111 00001 00011 00000000  00101 // reg[5] = reg[1] & reg[3]               and x5, x1, x3  # получаем последний бит числа
  0 0 01 00000 00010 00101 00000000  00010 // reg[2] = reg[2] + reg[5]               add x2, x2, x5  # добавляем его к счетчику единиц
  0 0 01 00101 00001 00011 00000000  00001 // reg[1] = reg[1] >> reg[3]              srl x1, x1, x3  # сдвигаем число вправо на 1
  1 0 00 00000 00000 00000 11111100  00000 // goto loop (-4)                         j loop          # продолжаем проверку следующего бита

// end:
  0 1 00 11000 00010 00011 00000011  00000 // if (reg[2] == reg[3]) PC = PC + 3      beq x2, x3, is_power   # если 1 одна, это степень 2
  0 0 00   00000000000000000000000   00100 // reg[4] = 0                             li x4, 0               # если не степень двойки, результат 0
  1 0 00 00000 00000 00000 00000010  00000 // goto finish (+2)                       j finish

// is_power:
  0 0 00   00000000000000000000001   00100 // reg[4] = 1                             li x4, 1  # если степень двойки, результат 1

// finish:
  1 0 00 00000 00100 00000 00000000  00000 // out_o = reg[4], PC = PC + 0            add x10, x4, x0   # записываем результат в выходной регистр
